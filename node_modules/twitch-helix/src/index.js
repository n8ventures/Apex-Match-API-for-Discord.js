"use strict";var _class,_temp,_initialiseProps,_stringify=require("babel-runtime/core-js/json/stringify"),_stringify2=_interopRequireDefault(_stringify),_assign=require("babel-runtime/core-js/object/assign"),_assign2=_interopRequireDefault(_assign),_asyncToGenerator2=require("babel-runtime/helpers/asyncToGenerator"),_asyncToGenerator3=_interopRequireDefault(_asyncToGenerator2),_promise=require("babel-runtime/core-js/promise"),_promise2=_interopRequireDefault(_promise),_getIterator2=require("babel-runtime/core-js/get-iterator"),_getIterator3=_interopRequireDefault(_getIterator2),_extends2=require("babel-runtime/helpers/extends"),_extends3=_interopRequireDefault(_extends2),_flatten2=require("lodash/flatten"),_flatten3=_interopRequireDefault(_flatten2),_chunk2=require("lodash/chunk"),_chunk3=_interopRequireDefault(_chunk2),_isEmpty2=require("lodash/isEmpty"),_isEmpty3=_interopRequireDefault(_isEmpty2),_events=require("events"),_events2=_interopRequireDefault(_events),_requestretry=require("requestretry"),_requestretry2=_interopRequireDefault(_requestretry);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}module.exports=(_temp=_class=class extends _events2.default{constructor(options){if(super(),_initialiseProps.call(this),(0,_isEmpty3.default)(options))throw new Error("TwitchHelix constructor needs options object as first argument");const credentialOptions=["clientId","clientSecret"];var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _step,_iterator=(0,_getIterator3.default)(credentialOptions);!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){const requiredOption=_step.value;if(!options[requiredOption])throw new Error(`Required TwitchHelix option ${requiredOption} is ${options[requiredOption]}`)}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError}}var _iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _step2,_iterator2=(0,_getIterator3.default)(credentialOptions);!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0){const requiredOption=_step2.value;if(options[requiredOption].match(/^x+$/i))throw new Error(`Option ${requiredOption} is ${options[requiredOption]} which looks like a placeholder value (You can generate real credential values in your Twitch Developers Dashboard)`)}}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{!_iteratorNormalCompletion2&&_iterator2.return&&_iterator2.return()}finally{if(_didIteratorError2)throw _iteratorError2}}this.options=(0,_extends3.default)({prematureExpirationTime:1e4,autoAuthorize:!0,smartRetry:!0},options),this.accessToken=null,this.refreshToken=null,this.tokenExpiration=null,this.rateLimit=null}},_initialiseProps=function(){var _this=this;this.log=(level,message)=>{this.emit("log-"+level,message)},this.authorize=()=>new _promise2.default((resolve,reject)=>{_requestretry2.default.post("https://api.twitch.tv/kraken/oauth2/token",{qs:{client_id:this.options.clientId,client_secret:this.options.clientSecret,grant_type:"client_credentials"},gzip:!0,json:!0},(error,response,body)=>error?void reject(error):void(this.accessToken=body.access_token,this.refreshToken=body.refresh_token,this.tokenExpiration=Date.now()+1e3*body.expires_in,resolve(this.tokenExpiration)))}),this.isAuthorized=()=>this.accessToken&&Date.now()-this.options.prematureExpirationTime>this.tokenExpiration,this.autoAuthorize=(0,_asyncToGenerator3.default)(function*(){!_this.isAuthorized()&&_this.options.autoAuthorize&&(yield _this.authorize())}),this.shouldRetryRequest=(error,response,body)=>{response.headers&&(this.rateLimit={limit:response.headers["ratelimit-limit"],remaining:response.headers["ratelimit-remaining"],resetDate:response.headers["ratelimit-reset"]});const reason=((error,response,body)=>_requestretry2.default.RetryStrategies.HTTPOrNetworkError(error,response)?response&&response.statusCode?`${response.statusCode} ${response.statusMessage}`:error.message||error:body?["Bad Request","Unauthorized"].includes(body.error)?body.error:void 0:"Received no response body")(error,response,body);if(reason){const retryDescription=response?`#${response.attempts} ${response.request.href}`:response;return this.log("warn",`Retry ${retryDescription} (${reason})`),!0}return!1},this.sendHelixRequest=(()=>{var _ref2=(0,_asyncToGenerator3.default)(function*(query,options){const apiResponse=yield _this.sendApiRequest(query,options);return apiResponse.body.data});return function(){return _ref2.apply(this,arguments)}})(),this.sendApiRequest=(query,options={})=>new _promise2.default((()=>{var _ref3=(0,_asyncToGenerator3.default)(function*(resolve,reject){const requestOptions=options.requestOptions;var _options$api=options.api;const api=_options$api===void 0?"helix":_options$api;yield _this.autoAuthorize();let queryOptions={json:!0,gzip:!0};if("helix"===api)queryOptions=(0,_assign2.default)(queryOptions,{baseUrl:"https://api.twitch.tv/helix",headers:{Authorization:`Bearer ${_this.accessToken}`}});else if("kraken"===api)queryOptions=(0,_assign2.default)(queryOptions,{baseUrl:"https://api.twitch.tv/kraken",headers:{Authorization:`OAuth ${_this.accessToken}`,Accept:"application/vnd.twitchtv.v5+json"}});else throw new Error(`Unknown Twitch API ${api}`);requestOptions&&(0,_assign2.default)(queryOptions,requestOptions),_this.options.smartRetry&&(queryOptions=(0,_assign2.default)(queryOptions,{maxAttempts:10,delayStrategy:function delayStrategy(){return 200*Math.pow(this.attempts,2)},retryStrategy:_this.shouldRetryRequest})),(0,_requestretry2.default)(query,queryOptions,function(error,response,body){if(response&&response.request&&_this.log("info",`${response.request.method} ${response.request.href}`),error)return void reject(error);if(!body||body.error){const errorMessage=`Got an unexpected response body from Twitch API: ${"object"==typeof body?(0,_stringify2.default)(body):body}`;return _this.log("error",errorMessage),void reject(errorMessage)}resolve({response,body})})});return function(){return _ref3.apply(this,arguments)}})()),this.getTwitchUserById=(()=>{var _ref4=(0,_asyncToGenerator3.default)(function*(id){const data=yield _this.sendHelixRequest("users",{requestOptions:{qs:{id}}});return data[0]||null});return function(){return _ref4.apply(this,arguments)}})(),this.getTwitchUserByName=(()=>{var _ref5=(0,_asyncToGenerator3.default)(function*(username){const data=yield _this.sendHelixRequest("users",{requestOptions:{qs:{login:username}}});return data[0]||null});return function(){return _ref5.apply(this,arguments)}})(),this.getTwitchUsersByName=(()=>{var _ref6=(0,_asyncToGenerator3.default)(function*(usernames){if(!usernames||(0,_isEmpty3.default)(usernames))return[];const queryPromises=[];var _iteratorNormalCompletion3=!0,_didIteratorError3=!1,_iteratorError3=void 0;try{for(var _step3,_iterator3=(0,_getIterator3.default)((0,_chunk3.default)(usernames,100));!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=!0){const usernamesChunk=_step3.value;queryPromises.push(_this.sendHelixRequest("users",{requestOptions:{qs:{login:usernamesChunk}}}))}}catch(err){_didIteratorError3=!0,_iteratorError3=err}finally{try{!_iteratorNormalCompletion3&&_iterator3.return&&_iterator3.return()}finally{if(_didIteratorError3)throw _iteratorError3}}const twitchUsers=yield _promise2.default.all(queryPromises);return(0,_flatten3.default)(twitchUsers)});return function(){return _ref6.apply(this,arguments)}})(),this.getStreamInfoById=(()=>{var _ref7=(0,_asyncToGenerator3.default)(function*(id){const data=yield _this.sendHelixRequest("streams",{requestOptions:{qs:{user_id:id}}});return data[0]||null});return function(){return _ref7.apply(this,arguments)}})(),this.getStreamInfoByUsername=(()=>{var _ref8=(0,_asyncToGenerator3.default)(function*(username){const data=yield _this.sendHelixRequest("streams",{requestOptions:{qs:{user_login:username}}});return data[0]||null});return function(){return _ref8.apply(this,arguments)}})(),this.getFollowDate=(()=>{var _ref9=(0,_asyncToGenerator3.default)(function*(streamer_id,follower_id){const data=yield _this.sendHelixRequest("users/follows",{requestOptions:{qs:{to_id:streamer_id,from_id:follower_id}}});return data[0]?new Date(data[0].followed_at):null});return function(){return _ref9.apply(this,arguments)}})()},_temp);